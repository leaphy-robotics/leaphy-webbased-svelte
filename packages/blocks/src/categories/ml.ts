import { dialog } from "blockly";
import { Msg, type WorkspaceSvg } from "blockly/core";
import type { ISerializer } from "blockly/core/interfaces/i_serializer";
import type { FlyoutDefinition } from "blockly/core/utils/toolbox";
import { type Sensor, sensorByType } from "./ml/sensors";
import {ClassManager} from "./ml/classManager";
import {DataFrame, DatasetManager} from "./ml/datasetManager";
import {SensorManager, SensorReference} from "./ml/sensorManager";

export interface SensorData {
	id: string;
	type: Sensor;
	settings: unknown;
}

export interface ModelLayer {
	activation: "softmax" | "relu";
	units: number;
}

// Event-driven ML system that coordinates the complete machine learning workflow
// Extends EventTarget to provide real-time state updates to the reactive UI layer
export class ML extends EventTarget {
	// Prevents modifications during serialization loading to make additional workspaces not clear ML State for the main workspace, primarily used for the additional workspace for customizing model architecture
	public freeze = false;

	public classes = new ClassManager(this);
	public sensors = new SensorManager(this);
	public datasets = new DatasetManager(this);

	public trainingID: string = crypto.randomUUID();

	// C++ header code for the trained model - generated by TensorFlow Lite converter
	public modelHeaders: string | null = null;
	// Controls Arduino code generation: data collection vs inference mode
	public generateInference = false;

	private _enabled = false;
	private _maxStep = 0;
	private _confusion: number[][] | null = null;
	private _structure: ModelLayer[] = [
		{ activation: "relu", units: 9 },
		{ activation: "relu", units: 6 },
	];

	get structure() {
		return this._structure;
	}

	// Reactive setters that dispatch events to notify Svelte state
	set structure(value: ModelLayer[]) {
		this._structure = value;
		this.dispatchEvent(new Event("updateStructure"));
	}

	get maxStep() {
		return this._maxStep;
	}

	set maxStep(maxStep: number) {
		this._maxStep = maxStep;
		this.dispatchEvent(new Event("updateMaxStep"));
	}

	get enabled() {
		return this._enabled;
	}

	set enabled(value: boolean) {
		this._enabled = value;
		this.dispatchEvent(new Event("updateEnabled"));
	}

	get confusion() {
		return this._confusion;
	}

	set confusion(value: number[][] | null) {
		this._confusion = value;
		this.dispatchEvent(new Event("updateConfusion"));
	}

	clear() {
		this.structure = [
			{ activation: "relu", units: 9 },
			{ activation: "relu", units: 6 },
		];

		this.classes.clear();
		this.sensors.clear();
		this.datasets.clear();

		this.maxStep = 0;
		this.enabled = false;
	}
}

export const ml = new ML();

interface SerialClass {
	id: string;
	name: string;
	key: string | null;
}

interface SerialDataset {
	id: string;
	date: number;
	data: DataFrame[];
}

interface MLState {
	structure: ModelLayer[];
	maxStep: number;
	trainingID: string;
	confusion: number[][] | null;
	enabled: boolean;
	classes: SerialClass[];
	datasets: SerialDataset[];
	sensors: SensorReference[];
	modelHeaders: string | null;
}

// Integrates with Blockly's workspace persistence system for ML state
export class MLSerializer implements ISerializer {
	public priority = 90;

	clear() {
		if (ml.freeze) return;

		ml.clear();
	}

	load(state: MLState) {
		if (ml.freeze) return;

		ml.structure = state.structure || ml.structure;
		ml.enabled = state.enabled;
		ml.modelHeaders = state.modelHeaders || null;
		ml.trainingID = state.trainingID || crypto.randomUUID();
		ml.maxStep = state.maxStep || 0;
		ml.confusion = state.confusion || null;

		for (const classState of state.classes) {
			ml.classes.createItem(classState.name, classState.id, classState.key);
		}
		for (const dataset of state.datasets) {
			ml.datasets.createItem(dataset.data, dataset.id, dataset.date);
		}
		for (const sensor of state.sensors) {
			ml.sensors.createItem(
				{ type: sensorByType[sensor.type], settings: sensor.settings },
				sensor.id,
			);
		}
	}

	save(): MLState | null {
		const classes: SerialClass[] = [];
		for (const classState of ml.classes.getItems()) {
			classes.push({
				id: classState.id,
				name: classState.name,
				key: classState.key,
			});
		}

		const datasets: SerialDataset[] = [];
		for (const dataset of ml.datasets.getItems()) {
			datasets.push({
				id: dataset.id,
				data: dataset.data,
				date: dataset.date.getTime(),
			});
		}

		const sensors: SensorReference[] = [];
		for (const sensor of ml.sensors.getItems()) {
			sensors.push({
				id: sensor.id,
				type: sensor.type.type,
				settings: sensor.settings,
			});
		}

		return {
			classes,
			datasets,
			sensors,
			enabled: ml.enabled,
			modelHeaders: ml.modelHeaders,
			trainingID: ml.trainingID,
			maxStep: ml.maxStep,
			confusion: ml.confusion,
			structure: ml.structure,
		};
	}
}

// Generates dynamic toolbox content based on current ML state
export default function (workspace: WorkspaceSvg) {
	let blockList: FlyoutDefinition = [
		{
			kind: "button",
			text: ml.enabled ? "%{BKY_ML_DISABLE}" : "%{BKY_ML_ENABLE}",
			callbackkey: "toggle_ml",
		},
	];

	if (ml.enabled) {
		blockList.push(
			{ kind: "sep", gap: 8 },
			{
				kind: "button",
				text: "%{BKY_ML_ADD_CLASS}",
				callbackkey: "add_class",
			},
		);

		if (ml.classes.getItems().length > 0) {
			blockList.push(
				{
					kind: "block",
					type: "ml_classify",
				},
				{ kind: "sep", gap: 8 },
				{
					kind: "block",
					type: "ml_certainty",
				},
			);
		}
	}

	workspace.registerButtonCallback("toggle_ml", () => {
		ml.enabled = !ml.enabled;
		workspace.refreshToolboxSelection();
	});

	// Adding a class clears existing datasets to prevent training data inconsistency
	workspace.registerButtonCallback("add_class", async () => {
		if (ml.datasets.getItems().length) {
			const confirmed = await new Promise<boolean>((resolve) =>
				dialog.confirm(Msg.CONFIRM_CLEAR, (result) => resolve(result)),
			);
			if (!confirmed) return;
		}

		ml.datasets.clear();

		dialog.prompt(Msg.NEW_CLASS, "", (name) => {
			if (!name) return;

			ml.classes.createItem(name);
			workspace.refreshToolboxSelection();
		});
	});

	return blockList;
}

export * from "./ml/classManager"
export * from "./ml/datasetManager"
export * from "./ml/sensorManager"
